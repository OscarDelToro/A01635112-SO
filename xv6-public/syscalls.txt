apagar.asm:    int $T_SYSCALL; \
apagar.asm:SYSCALL(fork)
apagar.asm:SYSCALL(exit)
apagar.asm:SYSCALL(wait)
apagar.asm:SYSCALL(pipe)
apagar.asm:SYSCALL(read)
apagar.asm:SYSCALL(write)
apagar.asm:SYSCALL(close)
apagar.asm:SYSCALL(kill)
apagar.asm:SYSCALL(exec)
apagar.asm:SYSCALL(open)
apagar.asm:SYSCALL(mknod)
apagar.asm:SYSCALL(unlink)
apagar.asm:SYSCALL(fstat)
apagar.asm:SYSCALL(link)
apagar.asm:SYSCALL(mkdir)
apagar.asm:SYSCALL(chdir)
apagar.asm:SYSCALL(dup)
apagar.asm:SYSCALL(getpid)
apagar.asm:SYSCALL(sbrk)
apagar.asm:SYSCALL(sleep)
apagar.asm:SYSCALL(uptime)
apagar.asm:SYSCALL(shutdown)
cat.asm:    int $T_SYSCALL; \
cat.asm:SYSCALL(fork)
cat.asm:SYSCALL(exit)
cat.asm:SYSCALL(wait)
cat.asm:SYSCALL(pipe)
cat.asm:SYSCALL(read)
cat.asm:SYSCALL(write)
cat.asm:SYSCALL(close)
cat.asm:SYSCALL(kill)
cat.asm:SYSCALL(exec)
cat.asm:SYSCALL(open)
cat.asm:SYSCALL(mknod)
cat.asm:SYSCALL(unlink)
cat.asm:SYSCALL(fstat)
cat.asm:SYSCALL(link)
cat.asm:SYSCALL(mkdir)
cat.asm:SYSCALL(chdir)
cat.asm:SYSCALL(dup)
cat.asm:SYSCALL(getpid)
cat.asm:SYSCALL(sbrk)
cat.asm:SYSCALL(sleep)
cat.asm:SYSCALL(uptime)
cat.asm:SYSCALL(shutdown)
defs.h:// syscall.c
defs.h:void            syscall(void);
echo.asm:    int $T_SYSCALL; \
echo.asm:SYSCALL(fork)
echo.asm:SYSCALL(exit)
echo.asm:SYSCALL(wait)
echo.asm:SYSCALL(pipe)
echo.asm:SYSCALL(read)
echo.asm:SYSCALL(write)
echo.asm:SYSCALL(close)
echo.asm:SYSCALL(kill)
echo.asm:SYSCALL(exec)
echo.asm:SYSCALL(open)
echo.asm:SYSCALL(mknod)
echo.asm:SYSCALL(unlink)
echo.asm:SYSCALL(fstat)
echo.asm:SYSCALL(link)
echo.asm:SYSCALL(mkdir)
echo.asm:SYSCALL(chdir)
echo.asm:SYSCALL(dup)
echo.asm:SYSCALL(getpid)
echo.asm:SYSCALL(sbrk)
echo.asm:SYSCALL(sleep)
echo.asm:SYSCALL(uptime)
echo.asm:SYSCALL(shutdown)
forktest.asm:    int $T_SYSCALL; \
forktest.asm:SYSCALL(fork)
forktest.asm:SYSCALL(exit)
forktest.asm:SYSCALL(wait)
forktest.asm:SYSCALL(pipe)
forktest.asm:SYSCALL(read)
forktest.asm:SYSCALL(write)
forktest.asm:SYSCALL(close)
forktest.asm:SYSCALL(kill)
forktest.asm:SYSCALL(exec)
forktest.asm:SYSCALL(open)
forktest.asm:SYSCALL(mknod)
forktest.asm:SYSCALL(unlink)
forktest.asm:SYSCALL(fstat)
forktest.asm:SYSCALL(link)
forktest.asm:SYSCALL(mkdir)
forktest.asm:SYSCALL(chdir)
forktest.asm:SYSCALL(dup)
forktest.asm:SYSCALL(getpid)
forktest.asm:SYSCALL(sbrk)
forktest.asm:SYSCALL(sleep)
forktest.asm:SYSCALL(uptime)
forktest.asm:SYSCALL(shutdown)
grep.asm:    int $T_SYSCALL; \
grep.asm:SYSCALL(fork)
grep.asm:SYSCALL(exit)
grep.asm:SYSCALL(wait)
grep.asm:SYSCALL(pipe)
grep.asm:SYSCALL(read)
grep.asm:SYSCALL(write)
grep.asm:SYSCALL(close)
grep.asm:SYSCALL(kill)
grep.asm:SYSCALL(exec)
grep.asm:SYSCALL(open)
grep.asm:SYSCALL(mknod)
grep.asm:SYSCALL(unlink)
grep.asm:SYSCALL(fstat)
grep.asm:SYSCALL(link)
grep.asm:SYSCALL(mkdir)
grep.asm:SYSCALL(chdir)
grep.asm:SYSCALL(dup)
grep.asm:SYSCALL(getpid)
grep.asm:SYSCALL(sbrk)
grep.asm:SYSCALL(sleep)
grep.asm:SYSCALL(uptime)
grep.asm:SYSCALL(shutdown)
init.asm:    int $T_SYSCALL; \
init.asm:SYSCALL(fork)
init.asm:SYSCALL(exit)
init.asm:SYSCALL(wait)
init.asm:SYSCALL(pipe)
init.asm:SYSCALL(read)
init.asm:SYSCALL(write)
init.asm:SYSCALL(close)
init.asm:SYSCALL(kill)
init.asm:SYSCALL(exec)
init.asm:SYSCALL(open)
init.asm:SYSCALL(mknod)
init.asm:SYSCALL(unlink)
init.asm:SYSCALL(fstat)
init.asm:SYSCALL(link)
init.asm:SYSCALL(mkdir)
init.asm:SYSCALL(chdir)
init.asm:SYSCALL(dup)
init.asm:SYSCALL(getpid)
init.asm:SYSCALL(sbrk)
init.asm:SYSCALL(sleep)
init.asm:SYSCALL(uptime)
init.asm:SYSCALL(shutdown)
initcode.asm:  int $T_SYSCALL
initcode.asm:  int $T_SYSCALL
initcode.d:initcode.o: initcode.S syscall.h traps.h
initcode.S:#include "syscall.h"
initcode.S:  int $T_SYSCALL
initcode.S:  int $T_SYSCALL
Binary file kernel matches
kernel.asm:80104930 <syscall>:
kernel.asm:syscall(void)
kernel.asm:  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
kernel.asm:8010494a:	77 1c                	ja     80104968 <syscall+0x38>
kernel.asm:80104955:	74 11                	je     80104968 <syscall+0x38>
kernel.asm:    curproc->tf->eax = syscalls[num]();
kernel.asm:  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
kernel.asm:  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
kernel.asm:  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
kernel.asm:  if(tf->trapno == T_SYSCALL){
kernel.asm:    syscall();
kernel.asm:801059d4:	e8 57 ef ff ff       	call   80104930 <syscall>
kernel.sym:00000000 syscall.c
kernel.sym:80107680 syscalls
kernel.sym:80104930 syscall
kill.asm:    int $T_SYSCALL; \
kill.asm:SYSCALL(fork)
kill.asm:SYSCALL(exit)
kill.asm:SYSCALL(wait)
kill.asm:SYSCALL(pipe)
kill.asm:SYSCALL(read)
kill.asm:SYSCALL(write)
kill.asm:SYSCALL(close)
kill.asm:SYSCALL(kill)
kill.asm:SYSCALL(exec)
kill.asm:SYSCALL(open)
kill.asm:SYSCALL(mknod)
kill.asm:SYSCALL(unlink)
kill.asm:SYSCALL(fstat)
kill.asm:SYSCALL(link)
kill.asm:SYSCALL(mkdir)
kill.asm:SYSCALL(chdir)
kill.asm:SYSCALL(dup)
kill.asm:SYSCALL(getpid)
kill.asm:SYSCALL(sbrk)
kill.asm:SYSCALL(sleep)
kill.asm:SYSCALL(uptime)
kill.asm:SYSCALL(shutdown)
ln.asm:    int $T_SYSCALL; \
ln.asm:SYSCALL(fork)
ln.asm:SYSCALL(exit)
ln.asm:SYSCALL(wait)
ln.asm:SYSCALL(pipe)
ln.asm:SYSCALL(read)
ln.asm:SYSCALL(write)
ln.asm:SYSCALL(close)
ln.asm:SYSCALL(kill)
ln.asm:SYSCALL(exec)
ln.asm:SYSCALL(open)
ln.asm:SYSCALL(mknod)
ln.asm:SYSCALL(unlink)
ln.asm:SYSCALL(fstat)
ln.asm:SYSCALL(link)
ln.asm:SYSCALL(mkdir)
ln.asm:SYSCALL(chdir)
ln.asm:SYSCALL(dup)
ln.asm:SYSCALL(getpid)
ln.asm:SYSCALL(sbrk)
ln.asm:SYSCALL(sleep)
ln.asm:SYSCALL(uptime)
ln.asm:SYSCALL(shutdown)
ls.asm:    int $T_SYSCALL; \
ls.asm:SYSCALL(fork)
ls.asm:SYSCALL(exit)
ls.asm:SYSCALL(wait)
ls.asm:SYSCALL(pipe)
ls.asm:SYSCALL(read)
ls.asm:SYSCALL(write)
ls.asm:SYSCALL(close)
ls.asm:SYSCALL(kill)
ls.asm:SYSCALL(exec)
ls.asm:SYSCALL(open)
ls.asm:SYSCALL(mknod)
ls.asm:SYSCALL(unlink)
ls.asm:SYSCALL(fstat)
ls.asm:SYSCALL(link)
ls.asm:SYSCALL(mkdir)
ls.asm:SYSCALL(chdir)
ls.asm:SYSCALL(dup)
ls.asm:SYSCALL(getpid)
ls.asm:SYSCALL(sbrk)
ls.asm:SYSCALL(sleep)
ls.asm:SYSCALL(uptime)
ls.asm:SYSCALL(shutdown)
Makefile:	syscall.o\
mkdir.asm:    int $T_SYSCALL; \
mkdir.asm:SYSCALL(fork)
mkdir.asm:SYSCALL(exit)
mkdir.asm:SYSCALL(wait)
mkdir.asm:SYSCALL(pipe)
mkdir.asm:SYSCALL(read)
mkdir.asm:SYSCALL(write)
mkdir.asm:SYSCALL(close)
mkdir.asm:SYSCALL(kill)
mkdir.asm:SYSCALL(exec)
mkdir.asm:SYSCALL(open)
mkdir.asm:SYSCALL(mknod)
mkdir.asm:SYSCALL(unlink)
mkdir.asm:SYSCALL(fstat)
mkdir.asm:SYSCALL(link)
mkdir.asm:SYSCALL(mkdir)
mkdir.asm:SYSCALL(chdir)
mkdir.asm:SYSCALL(dup)
mkdir.asm:SYSCALL(getpid)
mkdir.asm:SYSCALL(sbrk)
mkdir.asm:SYSCALL(sleep)
mkdir.asm:SYSCALL(uptime)
mkdir.asm:SYSCALL(shutdown)
proc.h:  struct trapframe *tf;        // Trap frame for current syscall
reboot.asm:    int $T_SYSCALL; \
reboot.asm:SYSCALL(fork)
reboot.asm:SYSCALL(exit)
reboot.asm:SYSCALL(wait)
reboot.asm:SYSCALL(pipe)
reboot.asm:SYSCALL(read)
reboot.asm:SYSCALL(write)
reboot.asm:SYSCALL(close)
reboot.asm:SYSCALL(kill)
reboot.asm:SYSCALL(exec)
reboot.asm:SYSCALL(open)
reboot.asm:SYSCALL(mknod)
reboot.asm:SYSCALL(unlink)
reboot.asm:SYSCALL(fstat)
reboot.asm:SYSCALL(link)
reboot.asm:SYSCALL(mkdir)
reboot.asm:SYSCALL(chdir)
reboot.asm:SYSCALL(dup)
reboot.asm:SYSCALL(getpid)
reboot.asm:SYSCALL(sbrk)
reboot.asm:SYSCALL(sleep)
reboot.asm:SYSCALL(uptime)
reboot.asm:SYSCALL(shutdown)
rm.asm:    int $T_SYSCALL; \
rm.asm:SYSCALL(fork)
rm.asm:SYSCALL(exit)
rm.asm:SYSCALL(wait)
rm.asm:SYSCALL(pipe)
rm.asm:SYSCALL(read)
rm.asm:SYSCALL(write)
rm.asm:SYSCALL(close)
rm.asm:SYSCALL(kill)
rm.asm:SYSCALL(exec)
rm.asm:SYSCALL(open)
rm.asm:SYSCALL(mknod)
rm.asm:SYSCALL(unlink)
rm.asm:SYSCALL(fstat)
rm.asm:SYSCALL(link)
rm.asm:SYSCALL(mkdir)
rm.asm:SYSCALL(chdir)
rm.asm:SYSCALL(dup)
rm.asm:SYSCALL(getpid)
rm.asm:SYSCALL(sbrk)
rm.asm:SYSCALL(sleep)
rm.asm:SYSCALL(uptime)
rm.asm:SYSCALL(shutdown)
runoff.list:syscall.h
runoff.list:syscall.c
runoff.spec:# syscall.h either
runoff.spec:# syscall.c either
sh.asm:    int $T_SYSCALL; \
sh.asm:SYSCALL(fork)
sh.asm:SYSCALL(exit)
sh.asm:SYSCALL(wait)
sh.asm:SYSCALL(pipe)
sh.asm:SYSCALL(read)
sh.asm:SYSCALL(write)
sh.asm:SYSCALL(close)
sh.asm:SYSCALL(kill)
sh.asm:SYSCALL(exec)
sh.asm:SYSCALL(open)
sh.asm:SYSCALL(mknod)
sh.asm:SYSCALL(unlink)
sh.asm:SYSCALL(fstat)
sh.asm:SYSCALL(link)
sh.asm:SYSCALL(mkdir)
sh.asm:SYSCALL(chdir)
sh.asm:SYSCALL(dup)
sh.asm:SYSCALL(getpid)
sh.asm:SYSCALL(sbrk)
sh.asm:SYSCALL(sleep)
sh.asm:SYSCALL(uptime)
sh.asm:SYSCALL(shutdown)
stressfs.asm:    int $T_SYSCALL; \
stressfs.asm:SYSCALL(fork)
stressfs.asm:SYSCALL(exit)
stressfs.asm:SYSCALL(wait)
stressfs.asm:SYSCALL(pipe)
stressfs.asm:SYSCALL(read)
stressfs.asm:SYSCALL(write)
stressfs.asm:SYSCALL(close)
stressfs.asm:SYSCALL(kill)
stressfs.asm:SYSCALL(exec)
stressfs.asm:SYSCALL(open)
stressfs.asm:SYSCALL(mknod)
stressfs.asm:SYSCALL(unlink)
stressfs.asm:SYSCALL(fstat)
stressfs.asm:SYSCALL(link)
stressfs.asm:SYSCALL(mkdir)
stressfs.asm:SYSCALL(chdir)
stressfs.asm:SYSCALL(dup)
stressfs.asm:SYSCALL(getpid)
stressfs.asm:SYSCALL(sbrk)
stressfs.asm:SYSCALL(sleep)
stressfs.asm:SYSCALL(uptime)
stressfs.asm:SYSCALL(shutdown)
syscall.c:#include "syscall.h"
syscall.c:// User code makes a system call with INT T_SYSCALL.
syscall.c:static int (*syscalls[])(void) = {
syscall.c:syscall(void)
syscall.c:  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
syscall.c:    curproc->tf->eax = syscalls[num]();
syscall.d:syscall.o: syscall.c /usr/include/stdc-predef.h types.h defs.h param.h \
syscall.d: memlayout.h mmu.h proc.h x86.h syscall.h
Binary file syscall.o matches
trap.c:  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
trap.c:  if(tf->trapno == T_SYSCALL){
trap.c:    syscall();
Binary file trap.o matches
traps.h:#define T_SYSCALL       64      // system call
usertests.asm:    int $T_SYSCALL; \
usertests.asm:SYSCALL(fork)
usertests.asm:SYSCALL(exit)
usertests.asm:SYSCALL(wait)
usertests.asm:SYSCALL(pipe)
usertests.asm:SYSCALL(read)
usertests.asm:SYSCALL(write)
usertests.asm:SYSCALL(close)
usertests.asm:SYSCALL(kill)
usertests.asm:SYSCALL(exec)
usertests.asm:SYSCALL(open)
usertests.asm:SYSCALL(mknod)
usertests.asm:SYSCALL(unlink)
usertests.asm:SYSCALL(fstat)
usertests.asm:SYSCALL(link)
usertests.asm:SYSCALL(mkdir)
usertests.asm:SYSCALL(chdir)
usertests.asm:SYSCALL(dup)
usertests.asm:SYSCALL(getpid)
usertests.asm:SYSCALL(sbrk)
usertests.asm:SYSCALL(sleep)
usertests.asm:SYSCALL(uptime)
usertests.asm:SYSCALL(shutdown)
usertests.c:#include "syscall.h"
usertests.c:      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
usertests.d: stat.h user.h fs.h fcntl.h syscall.h traps.h memlayout.h
usys.S:#include "syscall.h"
usys.S:#define SYSCALL(name) \
usys.S:    int $T_SYSCALL; \
usys.S:SYSCALL(fork)
usys.S:SYSCALL(exit)
usys.S:SYSCALL(wait)
usys.S:SYSCALL(pipe)
usys.S:SYSCALL(read)
usys.S:SYSCALL(write)
usys.S:SYSCALL(close)
usys.S:SYSCALL(kill)
usys.S:SYSCALL(exec)
usys.S:SYSCALL(open)
usys.S:SYSCALL(mknod)
usys.S:SYSCALL(unlink)
usys.S:SYSCALL(fstat)
usys.S:SYSCALL(link)
usys.S:SYSCALL(mkdir)
usys.S:SYSCALL(chdir)
usys.S:SYSCALL(dup)
usys.S:SYSCALL(getpid)
usys.S:SYSCALL(sbrk)
usys.S:SYSCALL(sleep)
usys.S:SYSCALL(uptime)
usys.S:SYSCALL(shutdown)
usys.S:SYSCALL(reboot)
wc.asm:    int $T_SYSCALL; \
wc.asm:SYSCALL(fork)
wc.asm:SYSCALL(exit)
wc.asm:SYSCALL(wait)
wc.asm:SYSCALL(pipe)
wc.asm:SYSCALL(read)
wc.asm:SYSCALL(write)
wc.asm:SYSCALL(close)
wc.asm:SYSCALL(kill)
wc.asm:SYSCALL(exec)
wc.asm:SYSCALL(open)
wc.asm:SYSCALL(mknod)
wc.asm:SYSCALL(unlink)
wc.asm:SYSCALL(fstat)
wc.asm:SYSCALL(link)
wc.asm:SYSCALL(mkdir)
wc.asm:SYSCALL(chdir)
wc.asm:SYSCALL(dup)
wc.asm:SYSCALL(getpid)
wc.asm:SYSCALL(sbrk)
wc.asm:SYSCALL(sleep)
wc.asm:SYSCALL(uptime)
wc.asm:SYSCALL(shutdown)
Binary file xv6.img matches
zombie.asm:    int $T_SYSCALL; \
zombie.asm:SYSCALL(fork)
zombie.asm:SYSCALL(exit)
zombie.asm:SYSCALL(wait)
zombie.asm:SYSCALL(pipe)
zombie.asm:SYSCALL(read)
zombie.asm:SYSCALL(write)
zombie.asm:SYSCALL(close)
zombie.asm:SYSCALL(kill)
zombie.asm:SYSCALL(exec)
zombie.asm:SYSCALL(open)
zombie.asm:SYSCALL(mknod)
zombie.asm:SYSCALL(unlink)
zombie.asm:SYSCALL(fstat)
zombie.asm:SYSCALL(link)
zombie.asm:SYSCALL(mkdir)
zombie.asm:SYSCALL(chdir)
zombie.asm:SYSCALL(dup)
zombie.asm:SYSCALL(getpid)
zombie.asm:SYSCALL(sbrk)
zombie.asm:SYSCALL(sleep)
zombie.asm:SYSCALL(uptime)
zombie.asm:SYSCALL(shutdown)
